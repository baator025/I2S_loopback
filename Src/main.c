/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "platform_definitions.h"
#include "stm32f4xx.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "i2s.h"
#include "clock.h"
#include "uart.h"
#include "dma.h"
#include "dbg_pin.h"

#include "pdm2pcm_glo.h"

#define LOG_BUFFER_LENGTH 10

static uint64_t dma_global_buffer = 0;
static uint16_t PCM_out;
static volatile BufferStatus_t buffer_readiness_flag;

static uint32_t reg_status[2];

// void initialize_pdm_filter(PDM_Filter_Handler_t *pdm_handle);
void initialize_pdm_filter(PDM_Filter_Handler_t * const pdm_handle, PDM_Filter_Config_t * const pdm_config);
void log_signal(char* signal_name, uint8_t signal_name_len, uint16_t signal_value);
void serialize_uint64(uint64_t input, uint8_t *output);
void enable_crc();

static uint32_t op_status;

int main(void)
{
    discovery_clock_100mhz_config();
    uart2_tx_init();
    printf("uart and clock configured\r\n");

    I2sInterface_t i2s_rx_if = {.i2s_config_id=I2S2_CONF,
                                .receive_interrupt_flag=INTERRUPTS_NOT_USED,
                                .clock_polarity = FALLING_EDGE,
                                .prescaler_config = {.clock_divider_value = 50,
                                                    .prescaler_odd_bit = NOT_ODD},
                                .pll_config = {.pll_m_value = 4,
                                                .pll_n_value = 200,
                                                .pll_r_value = 4},
                                .i2s_mode = MASTER_RECEIVER};
    i2s_init(&i2s_rx_if);

    // I2sInterface_t i2s_rx_if = {.i2s_config_id=I2S4_CONF,
    //                             .receive_interrupt_flag=INTERRUPTS_NOT_USED,
    //                             .clock_polarity = FALLING_EDGE,
    //                             .prescaler_config = {.clock_divider_value = 50,
    //                                                 .prescaler_odd_bit = NOT_ODD},
    //                             .pll_config = {.pll_m_value = 4,
    //                                             .pll_n_value = 200,
    //                                             .pll_r_value = 4},
    //                             .i2s_mode = MASTER_RECEIVER};

    // i2s_init(&i2s_rx_if);

    // I2sInterface_t i2s_tx_if = {.i2s_config_id=I2S3_CONF,
    //                             .receive_interrupt_flag=INTERRUPTS_NOT_USED,
    //                             .clock_polarity = FALLING_EDGE,
    //                             .prescaler_config = {.clock_divider_value = 50,
    //                                                 .prescaler_odd_bit = NOT_ODD},
    //                             .pll_config = {.pll_m_value = 4,
    //                                             .pll_n_value = 200,
    //                                             .pll_r_value = 4},
    //                             .i2s_mode = SLAVE_TRANSMITTER};

    // i2s_init(&i2s_tx_if);

    Dma_t i2s_2_dma = { .dma_main_register = DMA_1,
                        .dma_stream = DMA1_Stream3,
                        .dma_direction = PERIPHERAL_TO_MEMORY,
                        .dma_irq = DMA1_Stream3_IRQn,
                        .dma_channel = 0,
                        .dma_data_length = 4,
                        .memory_address = &dma_global_buffer,
                        .memory_data_size = HALF_WORD,
                        .peripheral_address = &(SPI2->DR),
                        .peripheral_data_size = HALF_WORD};

    dma_init(&dma_global_buffer, &buffer_readiness_flag, &i2s_2_dma);
    configure_debug_pin();

    // Dma_t i2s_4_dma = { .dma_main_register = DMA_2,
    //                     .dma_stream = DMA2_Stream0,
    //                     .dma_direction = PERIPHERAL_TO_MEMORY,
    //                     .dma_irq = DMA2_Stream0_IRQn,
    //                     .dma_channel = 4,
    //                     .dma_data_length = 4,
    //                     .memory_address = &dma_global_buffer,
    //                     .memory_data_size = HALF_WORD,
    //                     .peripheral_address = &(SPI4->DR),
    //                     .peripheral_data_size = HALF_WORD};
    // dma_init(&dma_global_buffer, &buffer_readiness_flag, &i2s_4_dma);

    // i2s_transmit(0xDEAD, &i2s_tx_if);
    // i2s_transmit(0xBEEF, &i2s_tx_if);
    // i2s_transmit(0xDEAD, &i2s_tx_if);
    // i2s_transmit(0xBEEF, &i2s_tx_if);

    PDM_Filter_Handler_t filter_handle;
    PDM_Filter_Config_t pdm_config;
    initialize_pdm_filter(&filter_handle, &pdm_config);
    uint8_t filter_data[8];

    char signal_name[4] = "sig";
    /* Loop forever */
	for(;;)
    {
        if(buffer_readiness_flag == BUFFER_READY)
        {
            buffer_readiness_flag = BUFFER_NOT_READY;
            serialize_uint64(dma_global_buffer, filter_data);
            op_status = PDM_Filter((uint8_t*) filter_data, (uint16_t*) &PCM_out, &filter_handle);
            if(PCM_out > 0)
            {
                while(1){};
            }
            log_signal(signal_name, sizeof(signal_name), PCM_out);
        }
        // for(int i = 0; i < 1000000; i++){}
    }
}

void put_to_uart_buff(char byte)
{
    while(!(USART2->SR & SR_TXE)){}
    USART2->DR = (byte);
}

void log_signal(char* signal_name, uint8_t signal_name_len, uint16_t signal_value)
{
    char buffer[LOG_BUFFER_LENGTH];
    itoa(signal_value, buffer, 16);
    for(uint8_t i = 0; i < signal_name_len - 1; i++)
    {
        put_to_uart_buff(signal_name[i]);
    }
    put_to_uart_buff(':');
    for(uint8_t i = 0; i < LOG_BUFFER_LENGTH - 1; i++)
    {
        if(buffer[i] == '\0') break;
        put_to_uart_buff(buffer[i]);
    }
    put_to_uart_buff('\r');
    put_to_uart_buff('\n');
}

void initialize_pdm_filter(PDM_Filter_Handler_t * const pdm_handle, PDM_Filter_Config_t * const pdm_config)
{
    enable_crc();

    pdm_handle->bit_order = PDM_FILTER_BIT_ORDER_LSB;
    pdm_handle->endianness = PDM_FILTER_ENDIANNESS_LE;
    pdm_handle->high_pass_tap =  2136746230;
    pdm_handle->in_ptr_channels = 1;
    pdm_handle->out_ptr_channels = 1;
    op_status = PDM_Filter_Init(pdm_handle);

    pdm_config->decimation_factor = PDM_FILTER_DEC_FACTOR_64;
    pdm_config->output_samples_number = 1;
    pdm_config->mic_gain = 10;
    op_status = PDM_Filter_setConfig(pdm_handle, pdm_config);

    while(1){};
}

void serialize_uint64(uint64_t input, uint8_t *output)
{
    uint64_t mask = 0xFF00000000000000;
    for(uint8_t it = 0; it < sizeof(uint64_t); it++)
    {
        output[it] = (input & mask) >> ((7-it)*8);
        mask = mask >> 8;
    }
}

void enable_crc()
{
    RCC->AHB1ENR |= RCC_AHB1ENR_CRCEN;
    CRC->CR |= CRC_CR_RESET;
}