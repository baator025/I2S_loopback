/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "platform_definitions.h"
#include "stm32f4xx.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "i2s.h"
#include "clock.h"
#include "uart.h"
#include "dma.h"
#include "dbg_pin.h"

#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"

#define LOG_BUFFER_LENGTH 10

static uint64_t dma_global_buffer = 0;
static uint16_t PCM_out;
static volatile BufferStatus_t buffer_readiness_flag;

static uint32_t reg_status[2];
void log_signal(const char* signal_name, uint8_t signal_name_len, uint16_t signal_value);
void serialize_uint64(uint64_t input, uint8_t *output);
void enable_crc();

static uint32_t op_status;

void init_task(void *params);
void work_task(void *params);

int main(void)
{
    xTaskCreate(init_task,
                "initialization task",
                100,
                NULL,
                (configMAX_PRIORITIES-2),
                NULL
                );

    xTaskCreate(work_task,
                "work task",
                100,
                NULL,
                (tskIDLE_PRIORITY+1),
                NULL);

    vTaskStartScheduler();
    /* Loop forever */
    int a = 0;
	for(;;)
    {
        a+=1;
    }
}

void init_task(void *params)
{
    discovery_clock_100mhz_config();
    uart2_tx_init();
    printf("uart and clock configured\r\n");

    I2sInterface_t i2s_rx_if = {.i2s_config_id=I2S2_CONF,
                                .receive_interrupt_flag=INTERRUPTS_NOT_USED,
                                .clock_polarity = FALLING_EDGE,
                                .prescaler_config = {.clock_divider_value = 50,
                                                    .prescaler_odd_bit = NOT_ODD},
                                .pll_config = {.pll_m_value = 4,
                                                .pll_n_value = 200,
                                                .pll_r_value = 4},
                                .i2s_mode = MASTER_RECEIVER};
    i2s_init(&i2s_rx_if);

    // I2sInterface_t i2s_rx_if = {.i2s_config_id=I2S4_CONF,
    //                             .receive_interrupt_flag=INTERRUPTS_NOT_USED,
    //                             .clock_polarity = FALLING_EDGE,
    //                             .prescaler_config = {.clock_divider_value = 50,
    //                                                 .prescaler_odd_bit = NOT_ODD},
    //                             .pll_config = {.pll_m_value = 4,
    //                                             .pll_n_value = 200,
    //                                             .pll_r_value = 4},
    //                             .i2s_mode = MASTER_RECEIVER};

    // i2s_init(&i2s_rx_if);

    // I2sInterface_t i2s_tx_if = {.i2s_config_id=I2S3_CONF,
    //                             .receive_interrupt_flag=INTERRUPTS_NOT_USED,
    //                             .clock_polarity = FALLING_EDGE,
    //                             .prescaler_config = {.clock_divider_value = 50,
    //                                                 .prescaler_odd_bit = NOT_ODD},
    //                             .pll_config = {.pll_m_value = 4,
    //                                             .pll_n_value = 200,
    //                                             .pll_r_value = 4},
    //                             .i2s_mode = SLAVE_TRANSMITTER};

    // i2s_init(&i2s_tx_if);

    Dma_t i2s_2_dma = { .dma_main_register = DMA_1,
                        .dma_stream = DMA1_Stream3,
                        .dma_direction = PERIPHERAL_TO_MEMORY,
                        .dma_irq = DMA1_Stream3_IRQn,
                        .dma_channel = 0,
                        .dma_data_length = 4,
                        .memory_address = &dma_global_buffer,
                        .memory_data_size = HALF_WORD,
                        .peripheral_address = &(SPI2->DR),
                        .peripheral_data_size = HALF_WORD};

    dma_init(&dma_global_buffer, &buffer_readiness_flag, &i2s_2_dma);
    configure_debug_pin();

    // Dma_t i2s_4_dma = { .dma_main_register = DMA_2,
    //                     .dma_stream = DMA2_Stream0,
    //                     .dma_direction = PERIPHERAL_TO_MEMORY,
    //                     .dma_irq = DMA2_Stream0_IRQn,
    //                     .dma_channel = 4,
    //                     .dma_data_length = 4,
    //                     .memory_address = &dma_global_buffer,
    //                     .memory_data_size = HALF_WORD,
    //                     .peripheral_address = &(SPI4->DR),
    //                     .peripheral_data_size = HALF_WORD};
    // dma_init(&dma_global_buffer, &buffer_readiness_flag, &i2s_4_dma);

    // i2s_transmit(0xDEAD, &i2s_tx_if);
    // i2s_transmit(0xBEEF, &i2s_tx_if);
    // i2s_transmit(0xDEAD, &i2s_tx_if);
    // i2s_transmit(0xBEEF, &i2s_tx_if);
    vTaskDelete(NULL);
}

void work_task(void *params)
{
    while(1)
    {
        const char signal_name[4] = "sig";
        if(buffer_readiness_flag == BUFFER_READY)
        {
            buffer_readiness_flag = BUFFER_NOT_READY;
            log_signal(signal_name, sizeof(signal_name), PCM_out);
        }
    }
}

void put_to_uart_buff(char byte)
{
    while(!(USART2->SR & SR_TXE)){}
    USART2->DR = (byte);
}

void log_signal(const char* signal_name, uint8_t signal_name_len, uint16_t signal_value)
{
    char buffer[LOG_BUFFER_LENGTH];
    itoa(signal_value, buffer, 16);
    for(uint8_t i = 0; i < signal_name_len - 1; i++)
    {
        put_to_uart_buff(signal_name[i]);
    }
    put_to_uart_buff(':');
    for(uint8_t i = 0; i < LOG_BUFFER_LENGTH - 1; i++)
    {
        if(buffer[i] == '\0') break;
        put_to_uart_buff(buffer[i]);
    }
    put_to_uart_buff('\r');
    put_to_uart_buff('\n');
}

void serialize_uint64(uint64_t input, uint8_t *output)
{
    uint64_t mask = 0xFF00000000000000;
    for(uint8_t it = 0; it < sizeof(uint64_t); it++)
    {
        output[it] = (input & mask) >> ((7-it)*8);
        mask = mask >> 8;
    }
}

void enable_crc()
{
    RCC->AHB1ENR |= RCC_AHB1ENR_CRCEN;
    CRC->CR |= CRC_CR_RESET;
}